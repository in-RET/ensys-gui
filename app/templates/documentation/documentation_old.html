{% extends 'base.html' %}
{% load custom_filters %}
{% load crispy_forms_tags %}
{% load static %}
{% load i18n %}

{% block head_block %}
{% endblock head_block %}

{% block start_body_scripts %}
{% endblock %}

{% block title %}{% translate "Documentation" %}{% endblock title %}

{% block content %}
<main>
	<section class="header">
		<div>
			<div class="header__left"></div>
			<h1 class="header__title">{% translate "Documentation" %}</h1>
			<div class="header__back"></div>
		</div>
	</section>
	<section class="standard-layout">
		<div>
			<h3>Hintergründe</h3>
			<p>Das Akronym „oemof“ steht für open energy modelling framework und ist eine in Python implementierte
				open-source Simulationsumgebung für Energiesysteme. Sie wird von einem Entwicklerteam des Reiner Lemoine
				Instituts Berlin, der Hochschule Flensburg und der Universität Bremen weiterentwickelt. „oemof“ ist
				objektorientiert und setzt auf das Framework Pyomo auf. Dieses erzeugt eine Datei für die lineare
				Programmierung, die die vom Solver zu lösende Zielfunktion und die Nebenbedingungen enthält. Der Solver
				ist die zugrunde liegende Software, welche diese Zielfunktionen und Nebenbedingungen versucht im Optimum
				zu lösen.</p>
			<p>All diese obig genannten Funktionen sind im hier vorliegenden Benutzerinterface nutzbar. Von der
				Erstellung von Energiesystemen, welche im Hintergrund in „oemof“ überführt werden bis hin zur Lösung
				dieser Systeme mit dem Bereitgestellten Solver auf dem Server der Hochschule Nordhausen, sofern das
				Online-Angebot der Hochschule genutzt wird.</p>

			<h3>Energiesystemkomponenten</h3>
			<p>Das Package „oemof.solph“ stellt Klassen zur Simulation der Bestandteile eines Energiesystems zur
				Verfügung, welches blockweise aufgebaut ist. So ist z.B. die Solarthermie ein Block und die
				Fernwärmelast ein anderer. Nachfolgend werden alle Klassen kurz erläutert.</p>
			<p>Das Energiesystem setzt sich aus Quellen, Senken, Speichern und Umwandlungsstellen zusammen. Jede
				Komponente ist mit mindestens einem Bus verbunden. Jeder Knoten im Programm wird mit einem Namen
				eindeutig bezeichnet. </p>
			<h4>Quellen</h4>
			<p>Für Energiequellen, denen Einspeiseprofil, Nennleistung, Kosten mit übergeben werden können, stehen dem
				Benutzer, je nach Erfahrung, verschiedene Blöcke zur Verfügung.</p>
			<p>Diese sind:</p>
			<ul>
				<li>Predefined Source (Default)</li>
				<li>Source(Expert)</li>
			</ul>
			<p>Energiequellen besitzen einen Ausgang und speise ihre Energie immer in einen Bus ein. Ebenfalls ist der
				entscheidende Unterschied beider Blöcke, das dem Default-User vorgefertigte Einspeiseprofile für
				verschiedene Technologie (Photovoltaik, Wind etc.) an die Hand gegeben werden.</p>

			<h4>Senken</h4>
			<p>Der Block „Sink“ repräsentiert das Verhalten von Verbrauchern. Einem Verbraucher können Lastprofil und
				Nennleistung zugeordnet werden; Kosten sind an der Stelle nicht notwendig, da Ziel der Optimierung die
				kostenoptimale Deckung der Last in jedem Zeitschritt ist.</p>
			<p>Die zur Verfügung stehenden Blöcke sind:</p>
			<ul>
				<li>Sink(Expert)</li>
				<li>Excess(Expert,Default)</li>
				<li>Export(Default)</li>
				<li>Predefined Load Profile(Default)</li>
				<li>Load Profile from Open Energy Platform (Default)</li>
			</ul>

			<h4>Speicher</h4>
			<p>Die zur Verfügung stehende Blöcke für Energiespeicher bilden die charakteristischen Eigenschaften
				verschiedener Speicherarten ab. Ein Block der Klasse hat einen Eingang und ebenfalls einen Ausgang. Die
				Nennkapazität („nominal_storage_capacity“) kann fest vorgegeben oder vom Optimierer (Solver) bestimmt
				werden. Die boolesche Variable „balanced“ ist standardmäßig auf „true“ gesetzt, was bedeutet, dass der
				Speicher am Ende den selben Füllstand hat, wie zu Beginn des Simulationszeitraums. Das
				„initial_storage_level“ bestimmt den Füllstand des Speichers im ersten Zeitschritt. Die C-Rate, mit der
				der maximal in einem Zeitschritt entnehmbare Anteil der Kapazität festgelegt wird, fließt in die
				„invest_relation_output_capacity“ ein. Die Eigenschaft wird in der Klasse mit der installierten,
				optimierten Nennkapazität multipliziert. Gleiches gilt für die „invest_relation_input_capacity“. Zudem
				können dem Objekt der Ein- und Ausspeicherwirkungsgrad der Speichertechnologie
				(„inflow_conversion_factor“/ „outflow_conversion_factor“) mit übergeben werden und bei saisonalen
				Speichern auch eine Verlustrate („loss_rate“), die den prozentualen Ladungsverlust zwischen zwei
				Zeitschritten beschreibt.</p>

			<h4>Transformer</h4>
			<p>Zum Erstellen von Energiewandlern stellt die Blöcke der Klasse Transformer() sicher, dass die zu- und
				abfließenden Energiemengen unter Berücksichtigung des gewünschten Wirkungsgrades in einem Zeitschritt
				identisch sind. Eine Instanz dieser Klasse kann beliebig viele Ein- und Ausgänge haben. Alle genannten
				Komponenten können mit Instanzen der Klasse „Bus“ zu einem Energiesystemmodell miteinander verknüpft
				werden. </p>

			<h4>Bus</h4>
			<p>Ein Bus ist in „oemof“ eine Sammelschiene, deren zu- und abfließende Energiemengen sich in jedem
				Zeitschritt ausgleichen.</p>
		</div>
		</div>
		</div>
	</section>

</main>
{% endblock content %}


{% block end_body_scripts %}

<script src="https://cdn.jsdelivr.net/npm/sweetalert2@10"></script>

{% endblock end_body_scripts %}